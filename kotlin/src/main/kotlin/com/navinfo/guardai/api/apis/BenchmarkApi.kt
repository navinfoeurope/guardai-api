/**
 * GuardAI Platform API
 *
 * GuardAI is an adversarial security assessment Platform for AI
 *
 * The version of the OpenAPI document: 1.0
 * Contact: info@navinfo.eu
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.navinfo.guardai.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.navinfo.guardai.api.models.BenchmarkRequest
import com.navinfo.guardai.api.models.BenchmarkResponse
import com.navinfo.guardai.api.models.BenchmarkTest
import com.navinfo.guardai.api.models.BenchmarkTestRequest
import com.navinfo.guardai.api.models.BenchmarkTestStatusResponse
import com.navinfo.guardai.api.models.DefenseRequest
import com.navinfo.guardai.api.models.FilterRequest

import com.squareup.moshi.Json

import com.navinfo.guardai.api.infrastructure.ApiClient
import com.navinfo.guardai.api.infrastructure.ApiResponse
import com.navinfo.guardai.api.infrastructure.ClientException
import com.navinfo.guardai.api.infrastructure.ClientError
import com.navinfo.guardai.api.infrastructure.ServerException
import com.navinfo.guardai.api.infrastructure.ServerError
import com.navinfo.guardai.api.infrastructure.MultiValueMap
import com.navinfo.guardai.api.infrastructure.PartConfig
import com.navinfo.guardai.api.infrastructure.RequestConfig
import com.navinfo.guardai.api.infrastructure.RequestMethod
import com.navinfo.guardai.api.infrastructure.ResponseType
import com.navinfo.guardai.api.infrastructure.Success
import com.navinfo.guardai.api.infrastructure.toMultiValue

class BenchmarkApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:8082")
        }
    }

    /**
     * Add a benchmark to an organization.
     * 
     * @param organizationId The organization ID.
     * @param benchmarkRequest benchmarkRequest
     * @return BenchmarkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addBenchmark(organizationId: kotlin.Long, benchmarkRequest: BenchmarkRequest) : BenchmarkResponse {
        val localVarResponse = addBenchmarkWithHttpInfo(organizationId = organizationId, benchmarkRequest = benchmarkRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add a benchmark to an organization.
     * 
     * @param organizationId The organization ID.
     * @param benchmarkRequest benchmarkRequest
     * @return ApiResponse<BenchmarkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addBenchmarkWithHttpInfo(organizationId: kotlin.Long, benchmarkRequest: BenchmarkRequest) : ApiResponse<BenchmarkResponse?> {
        val localVariableConfig = addBenchmarkRequestConfig(organizationId = organizationId, benchmarkRequest = benchmarkRequest)

        return request<BenchmarkRequest, BenchmarkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addBenchmark
     *
     * @param organizationId The organization ID.
     * @param benchmarkRequest benchmarkRequest
     * @return RequestConfig
     */
    fun addBenchmarkRequestConfig(organizationId: kotlin.Long, benchmarkRequest: BenchmarkRequest) : RequestConfig<BenchmarkRequest> {
        val localVariableBody = benchmarkRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("organizationId", listOf(organizationId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/benchmarks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Add new test.
     * 
     * @param id The benchmark ID.
     * @param name name
     * @return BenchmarkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addBenchmarkTest(id: kotlin.Long, name: kotlin.String) : BenchmarkResponse {
        val localVarResponse = addBenchmarkTestWithHttpInfo(id = id, name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add new test.
     * 
     * @param id The benchmark ID.
     * @param name name
     * @return ApiResponse<BenchmarkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addBenchmarkTestWithHttpInfo(id: kotlin.Long, name: kotlin.String) : ApiResponse<BenchmarkResponse?> {
        val localVariableConfig = addBenchmarkTestRequestConfig(id = id, name = name)

        return request<Unit, BenchmarkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addBenchmarkTest
     *
     * @param id The benchmark ID.
     * @param name name
     * @return RequestConfig
     */
    fun addBenchmarkTestRequestConfig(id: kotlin.Long, name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("name", listOf(name.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/benchmarks/{id}/addtest".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Add defense to benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param defense The defense.
     * @return BenchmarkTest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addBenchmarkTestDefense(id: kotlin.Long, testId: kotlin.Int, defense: DefenseRequest) : BenchmarkTest {
        val localVarResponse = addBenchmarkTestDefenseWithHttpInfo(id = id, testId = testId, defense = defense)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkTest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add defense to benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param defense The defense.
     * @return ApiResponse<BenchmarkTest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addBenchmarkTestDefenseWithHttpInfo(id: kotlin.Long, testId: kotlin.Int, defense: DefenseRequest) : ApiResponse<BenchmarkTest?> {
        val localVariableConfig = addBenchmarkTestDefenseRequestConfig(id = id, testId = testId, defense = defense)

        return request<DefenseRequest, BenchmarkTest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addBenchmarkTestDefense
     *
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param defense The defense.
     * @return RequestConfig
     */
    fun addBenchmarkTestDefenseRequestConfig(id: kotlin.Long, testId: kotlin.Int, defense: DefenseRequest) : RequestConfig<DefenseRequest> {
        val localVariableBody = defense
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/benchmarks/{id}/{testId}/defense".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Add filter to benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param filterRequest filterRequest
     * @return BenchmarkTest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addBenchmarkTestFilter(id: kotlin.Long, testId: kotlin.Int, filterRequest: FilterRequest) : BenchmarkTest {
        val localVarResponse = addBenchmarkTestFilterWithHttpInfo(id = id, testId = testId, filterRequest = filterRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkTest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add filter to benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param filterRequest filterRequest
     * @return ApiResponse<BenchmarkTest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addBenchmarkTestFilterWithHttpInfo(id: kotlin.Long, testId: kotlin.Int, filterRequest: FilterRequest) : ApiResponse<BenchmarkTest?> {
        val localVariableConfig = addBenchmarkTestFilterRequestConfig(id = id, testId = testId, filterRequest = filterRequest)

        return request<FilterRequest, BenchmarkTest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addBenchmarkTestFilter
     *
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param filterRequest filterRequest
     * @return RequestConfig
     */
    fun addBenchmarkTestFilterRequestConfig(id: kotlin.Long, testId: kotlin.Int, filterRequest: FilterRequest) : RequestConfig<FilterRequest> {
        val localVariableBody = filterRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/benchmarks/{id}/{testId}/filter".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete a benchmark.
     * 
     * @param id The benchmark ID.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteBenchmark(id: kotlin.Long) : Unit {
        val localVarResponse = deleteBenchmarkWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a benchmark.
     * 
     * @param id The benchmark ID.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteBenchmarkWithHttpInfo(id: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = deleteBenchmarkRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteBenchmark
     *
     * @param id The benchmark ID.
     * @return RequestConfig
     */
    fun deleteBenchmarkRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/benchmarks/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete a benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return BenchmarkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteBenchmarkTest(id: kotlin.Long, testId: kotlin.Int) : BenchmarkResponse {
        val localVarResponse = deleteBenchmarkTestWithHttpInfo(id = id, testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return ApiResponse<BenchmarkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteBenchmarkTestWithHttpInfo(id: kotlin.Long, testId: kotlin.Int) : ApiResponse<BenchmarkResponse?> {
        val localVariableConfig = deleteBenchmarkTestRequestConfig(id = id, testId = testId)

        return request<Unit, BenchmarkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteBenchmarkTest
     *
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return RequestConfig
     */
    fun deleteBenchmarkTestRequestConfig(id: kotlin.Long, testId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/benchmarks/{id}/{testId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get a benchmark.
     * 
     * @param id The benchmark ID.
     * @return BenchmarkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenchmark(id: kotlin.Long) : BenchmarkResponse {
        val localVarResponse = getBenchmarkWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get a benchmark.
     * 
     * @param id The benchmark ID.
     * @return ApiResponse<BenchmarkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenchmarkWithHttpInfo(id: kotlin.Long) : ApiResponse<BenchmarkResponse?> {
        val localVariableConfig = getBenchmarkRequestConfig(id = id)

        return request<Unit, BenchmarkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenchmark
     *
     * @param id The benchmark ID.
     * @return RequestConfig
     */
    fun getBenchmarkRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/benchmarks/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get benchmark test status.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return BenchmarkTestStatusResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenchmarkTestStatus(id: kotlin.Long, testId: kotlin.Int) : BenchmarkTestStatusResponse {
        val localVarResponse = getBenchmarkTestStatusWithHttpInfo(id = id, testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkTestStatusResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get benchmark test status.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return ApiResponse<BenchmarkTestStatusResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenchmarkTestStatusWithHttpInfo(id: kotlin.Long, testId: kotlin.Int) : ApiResponse<BenchmarkTestStatusResponse?> {
        val localVariableConfig = getBenchmarkTestStatusRequestConfig(id = id, testId = testId)

        return request<Unit, BenchmarkTestStatusResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenchmarkTestStatus
     *
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return RequestConfig
     */
    fun getBenchmarkTestStatusRequestConfig(id: kotlin.Long, testId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/benchmarks/{id}/{testId}/status".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get list of benchmarks.
     * 
     * @return kotlin.collections.List<BenchmarkResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenchmarks() : kotlin.collections.List<BenchmarkResponse> {
        val localVarResponse = getBenchmarksWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BenchmarkResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get list of benchmarks.
     * 
     * @return ApiResponse<kotlin.collections.List<BenchmarkResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenchmarksWithHttpInfo() : ApiResponse<kotlin.collections.List<BenchmarkResponse>?> {
        val localVariableConfig = getBenchmarksRequestConfig()

        return request<Unit, kotlin.collections.List<BenchmarkResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenchmarks
     *
     * @return RequestConfig
     */
    fun getBenchmarksRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/benchmarks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Remove filter from benchmark test.
     * 
     * @param filterId The filter ID.
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return BenchmarkTest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeBenchmarkFilter(filterId: kotlin.Long, id: kotlin.Long, testId: kotlin.Int) : BenchmarkTest {
        val localVarResponse = removeBenchmarkFilterWithHttpInfo(filterId = filterId, id = id, testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkTest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove filter from benchmark test.
     * 
     * @param filterId The filter ID.
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return ApiResponse<BenchmarkTest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeBenchmarkFilterWithHttpInfo(filterId: kotlin.Long, id: kotlin.Long, testId: kotlin.Int) : ApiResponse<BenchmarkTest?> {
        val localVariableConfig = removeBenchmarkFilterRequestConfig(filterId = filterId, id = id, testId = testId)

        return request<Unit, BenchmarkTest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeBenchmarkFilter
     *
     * @param filterId The filter ID.
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return RequestConfig
     */
    fun removeBenchmarkFilterRequestConfig(filterId: kotlin.Long, id: kotlin.Long, testId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/benchmarks/{id}/{testId}/{filterId}".replace("{"+"filterId"+"}", encodeURIComponent(filterId.toString())).replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Remove defense from benchmark test.
     * 
     * @param defenseId The defense ID.
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return BenchmarkTest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeBenchmarkTestDefense(defenseId: kotlin.Long, id: kotlin.Long, testId: kotlin.Int) : BenchmarkTest {
        val localVarResponse = removeBenchmarkTestDefenseWithHttpInfo(defenseId = defenseId, id = id, testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkTest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove defense from benchmark test.
     * 
     * @param defenseId The defense ID.
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return ApiResponse<BenchmarkTest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeBenchmarkTestDefenseWithHttpInfo(defenseId: kotlin.Long, id: kotlin.Long, testId: kotlin.Int) : ApiResponse<BenchmarkTest?> {
        val localVariableConfig = removeBenchmarkTestDefenseRequestConfig(defenseId = defenseId, id = id, testId = testId)

        return request<Unit, BenchmarkTest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeBenchmarkTestDefense
     *
     * @param defenseId The defense ID.
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return RequestConfig
     */
    fun removeBenchmarkTestDefenseRequestConfig(defenseId: kotlin.Long, id: kotlin.Long, testId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/benchmarks/{id}/{testId}/defense/{defenseId}".replace("{"+"defenseId"+"}", encodeURIComponent(defenseId.toString())).replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Start a benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun startBenchmarkTest(id: kotlin.Long, testId: kotlin.Int) : Unit {
        val localVarResponse = startBenchmarkTestWithHttpInfo(id = id, testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Start a benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun startBenchmarkTestWithHttpInfo(id: kotlin.Long, testId: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = startBenchmarkTestRequestConfig(id = id, testId = testId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation startBenchmarkTest
     *
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return RequestConfig
     */
    fun startBenchmarkTestRequestConfig(id: kotlin.Long, testId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/benchmarks/{id}/{testId}/start".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Stop a benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stopBenchmarkTest(id: kotlin.Long, testId: kotlin.Int) : Unit {
        val localVarResponse = stopBenchmarkTestWithHttpInfo(id = id, testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Stop a benchmark test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stopBenchmarkTestWithHttpInfo(id: kotlin.Long, testId: kotlin.Int) : ApiResponse<Unit?> {
        val localVariableConfig = stopBenchmarkTestRequestConfig(id = id, testId = testId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stopBenchmarkTest
     *
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @return RequestConfig
     */
    fun stopBenchmarkTestRequestConfig(id: kotlin.Long, testId: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/benchmarks/{id}/{testId}/stop".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update benchmark.
     * 
     * @param id The benchmark ID.
     * @param benchmarkRequest benchmarkRequest
     * @return BenchmarkResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBenchmark(id: kotlin.Long, benchmarkRequest: BenchmarkRequest) : BenchmarkResponse {
        val localVarResponse = updateBenchmarkWithHttpInfo(id = id, benchmarkRequest = benchmarkRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update benchmark.
     * 
     * @param id The benchmark ID.
     * @param benchmarkRequest benchmarkRequest
     * @return ApiResponse<BenchmarkResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBenchmarkWithHttpInfo(id: kotlin.Long, benchmarkRequest: BenchmarkRequest) : ApiResponse<BenchmarkResponse?> {
        val localVariableConfig = updateBenchmarkRequestConfig(id = id, benchmarkRequest = benchmarkRequest)

        return request<BenchmarkRequest, BenchmarkResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBenchmark
     *
     * @param id The benchmark ID.
     * @param benchmarkRequest benchmarkRequest
     * @return RequestConfig
     */
    fun updateBenchmarkRequestConfig(id: kotlin.Long, benchmarkRequest: BenchmarkRequest) : RequestConfig<BenchmarkRequest> {
        val localVariableBody = benchmarkRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/benchmarks/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param testRequest The test update request.
     * @return BenchmarkTest
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateBenchmarkTest(id: kotlin.Long, testId: kotlin.Int, testRequest: BenchmarkTestRequest) : BenchmarkTest {
        val localVarResponse = updateBenchmarkTestWithHttpInfo(id = id, testId = testId, testRequest = testRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BenchmarkTest
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update test.
     * 
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param testRequest The test update request.
     * @return ApiResponse<BenchmarkTest?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateBenchmarkTestWithHttpInfo(id: kotlin.Long, testId: kotlin.Int, testRequest: BenchmarkTestRequest) : ApiResponse<BenchmarkTest?> {
        val localVariableConfig = updateBenchmarkTestRequestConfig(id = id, testId = testId, testRequest = testRequest)

        return request<BenchmarkTestRequest, BenchmarkTest>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateBenchmarkTest
     *
     * @param id The benchmark ID.
     * @param testId The test ID.
     * @param testRequest The test update request.
     * @return RequestConfig
     */
    fun updateBenchmarkTestRequestConfig(id: kotlin.Long, testId: kotlin.Int, testRequest: BenchmarkTestRequest) : RequestConfig<BenchmarkTestRequest> {
        val localVariableBody = testRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/benchmarks/{id}/{testId}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
