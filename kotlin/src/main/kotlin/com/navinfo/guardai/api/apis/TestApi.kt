/**
 * GuardAI Platform API
 *
 * GuardAI is an adversarial security assessment Platform for AI
 *
 * The version of the OpenAPI document: 1.0
 * Contact: info@navinfo.eu
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.navinfo.guardai.api.apis

import java.io.IOException
import okhttp3.OkHttpClient
import okhttp3.HttpUrl

import com.navinfo.guardai.api.models.DefenseRequest
import com.navinfo.guardai.api.models.DefenseResponse
import com.navinfo.guardai.api.models.FilterRequest
import com.navinfo.guardai.api.models.StatusRequest
import com.navinfo.guardai.api.models.TestRequest
import com.navinfo.guardai.api.models.TestResponse
import com.navinfo.guardai.api.models.TestRunRequest
import com.navinfo.guardai.api.models.TestRunResponse

import com.squareup.moshi.Json

import com.navinfo.guardai.api.infrastructure.ApiClient
import com.navinfo.guardai.api.infrastructure.ApiResponse
import com.navinfo.guardai.api.infrastructure.ClientException
import com.navinfo.guardai.api.infrastructure.ClientError
import com.navinfo.guardai.api.infrastructure.ServerException
import com.navinfo.guardai.api.infrastructure.ServerError
import com.navinfo.guardai.api.infrastructure.MultiValueMap
import com.navinfo.guardai.api.infrastructure.PartConfig
import com.navinfo.guardai.api.infrastructure.RequestConfig
import com.navinfo.guardai.api.infrastructure.RequestMethod
import com.navinfo.guardai.api.infrastructure.ResponseType
import com.navinfo.guardai.api.infrastructure.Success
import com.navinfo.guardai.api.infrastructure.toMultiValue

class TestApi(basePath: kotlin.String = defaultBasePath, client: OkHttpClient = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "http://localhost:8082")
        }
    }

    /**
     * Add defense.
     * 
     * @param testId The test id.
     * @param defenseRequest The defense object
     * @return TestResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addDefense(testId: kotlin.Long, defenseRequest: DefenseRequest) : TestResponse {
        val localVarResponse = addDefenseWithHttpInfo(testId = testId, defenseRequest = defenseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add defense.
     * 
     * @param testId The test id.
     * @param defenseRequest The defense object
     * @return ApiResponse<TestResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addDefenseWithHttpInfo(testId: kotlin.Long, defenseRequest: DefenseRequest) : ApiResponse<TestResponse?> {
        val localVariableConfig = addDefenseRequestConfig(testId = testId, defenseRequest = defenseRequest)

        return request<DefenseRequest, TestResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addDefense
     *
     * @param testId The test id.
     * @param defenseRequest The defense object
     * @return RequestConfig
     */
    fun addDefenseRequestConfig(testId: kotlin.Long, defenseRequest: DefenseRequest) : RequestConfig<DefenseRequest> {
        val localVariableBody = defenseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/tests/{testId}/defense".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Add a filter.
     * 
     * @param id The test id.
     * @param attackRequest attackRequest
     * @return TestResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addFilter(id: kotlin.Long, attackRequest: FilterRequest) : TestResponse {
        val localVarResponse = addFilterWithHttpInfo(id = id, attackRequest = attackRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add a filter.
     * 
     * @param id The test id.
     * @param attackRequest attackRequest
     * @return ApiResponse<TestResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addFilterWithHttpInfo(id: kotlin.Long, attackRequest: FilterRequest) : ApiResponse<TestResponse?> {
        val localVariableConfig = addFilterRequestConfig(id = id, attackRequest = attackRequest)

        return request<FilterRequest, TestResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addFilter
     *
     * @param id The test id.
     * @param attackRequest attackRequest
     * @return RequestConfig
     */
    fun addFilterRequestConfig(id: kotlin.Long, attackRequest: FilterRequest) : RequestConfig<FilterRequest> {
        val localVariableBody = attackRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/tests/{id}/filter".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Add a new test.
     * 
     * @param test test
     * @return TestResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun addTest(test: TestRequest) : TestResponse {
        val localVarResponse = addTestWithHttpInfo(test = test)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Add a new test.
     * 
     * @param test test
     * @return ApiResponse<TestResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun addTestWithHttpInfo(test: TestRequest) : ApiResponse<TestResponse?> {
        val localVariableConfig = addTestRequestConfig(test = test)

        return request<TestRequest, TestResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation addTest
     *
     * @param test test
     * @return RequestConfig
     */
    fun addTestRequestConfig(test: TestRequest) : RequestConfig<TestRequest> {
        val localVariableBody = test
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/api/v1/tests",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Delete a test.
     * 
     * @param id id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deleteTest(id: kotlin.Long) : Unit {
        val localVarResponse = deleteTestWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Delete a test.
     * 
     * @param id id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun deleteTestWithHttpInfo(id: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = deleteTestRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deleteTest
     *
     * @param id id
     * @return RequestConfig
     */
    fun deleteTestRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/tests/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get defenses.
     * 
     * @param testId testId
     * @return kotlin.collections.List<DefenseResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getDefenses(testId: kotlin.Long) : kotlin.collections.List<DefenseResponse> {
        val localVarResponse = getDefensesWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<DefenseResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get defenses.
     * 
     * @param testId testId
     * @return ApiResponse<kotlin.collections.List<DefenseResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getDefensesWithHttpInfo(testId: kotlin.Long) : ApiResponse<kotlin.collections.List<DefenseResponse>?> {
        val localVariableConfig = getDefensesRequestConfig(testId = testId)

        return request<Unit, kotlin.collections.List<DefenseResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getDefenses
     *
     * @param testId testId
     * @return RequestConfig
     */
    fun getDefensesRequestConfig(testId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/tests/{testId}/defenses".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get test status.
     * 
     * @param testId testId
     * @return TestResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStatus(testId: kotlin.Long) : TestResponse {
        val localVarResponse = getStatusWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get test status.
     * 
     * @param testId testId
     * @return ApiResponse<TestResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStatusWithHttpInfo(testId: kotlin.Long) : ApiResponse<TestResponse?> {
        val localVariableConfig = getStatusRequestConfig(testId = testId)

        return request<Unit, TestResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStatus
     *
     * @param testId testId
     * @return RequestConfig
     */
    fun getStatusRequestConfig(testId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/tests/{testId}/status".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Get tests for a project.
     * 
     * @param projectId The project id.
     * @return kotlin.collections.List<TestResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTests(projectId: kotlin.Long) : kotlin.collections.List<TestResponse> {
        val localVarResponse = getTestsWithHttpInfo(projectId = projectId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<TestResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get tests for a project.
     * 
     * @param projectId The project id.
     * @return ApiResponse<kotlin.collections.List<TestResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTestsWithHttpInfo(projectId: kotlin.Long) : ApiResponse<kotlin.collections.List<TestResponse>?> {
        val localVariableConfig = getTestsRequestConfig(projectId = projectId)

        return request<Unit, kotlin.collections.List<TestResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTests
     *
     * @param projectId The project id.
     * @return RequestConfig
     */
    fun getTestsRequestConfig(projectId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("projectId", listOf(projectId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/tests",
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Remove defense.
     * 
     * @param id The defense id.
     * @param testId The test id.
     * @return TestResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeDefense(id: kotlin.Long, testId: kotlin.Long) : TestResponse {
        val localVarResponse = removeDefenseWithHttpInfo(id = id, testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove defense.
     * 
     * @param id The defense id.
     * @param testId The test id.
     * @return ApiResponse<TestResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeDefenseWithHttpInfo(id: kotlin.Long, testId: kotlin.Long) : ApiResponse<TestResponse?> {
        val localVariableConfig = removeDefenseRequestConfig(id = id, testId = testId)

        return request<Unit, TestResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeDefense
     *
     * @param id The defense id.
     * @param testId The test id.
     * @return RequestConfig
     */
    fun removeDefenseRequestConfig(id: kotlin.Long, testId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/tests/{testId}/defense/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Remove a filter.
     * 
     * @param id The filter id.
     * @param testId The test id.
     * @return TestResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun removeFilter(id: kotlin.Long, testId: kotlin.Long) : TestResponse {
        val localVarResponse = removeFilterWithHttpInfo(id = id, testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Remove a filter.
     * 
     * @param id The filter id.
     * @param testId The test id.
     * @return ApiResponse<TestResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun removeFilterWithHttpInfo(id: kotlin.Long, testId: kotlin.Long) : ApiResponse<TestResponse?> {
        val localVariableConfig = removeFilterRequestConfig(id = id, testId = testId)

        return request<Unit, TestResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation removeFilter
     *
     * @param id The filter id.
     * @param testId The test id.
     * @return RequestConfig
     */
    fun removeFilterRequestConfig(id: kotlin.Long, testId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/api/v1/tests/{testId}/filter/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())).replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Start a test.
     * 
     * @param testId The test id.
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun startTest(testId: kotlin.Long) : Unit {
        val localVarResponse = startTestWithHttpInfo(testId = testId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Start a test.
     * 
     * @param testId The test id.
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun startTestWithHttpInfo(testId: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = startTestRequestConfig(testId = testId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation startTest
     *
     * @param testId The test id.
     * @return RequestConfig
     */
    fun startTestRequestConfig(testId: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/tests/{testId}/start".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Stop all the running jobs in a test.
     * 
     * @param id id
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun stopTest(id: kotlin.Long) : Unit {
        val localVarResponse = stopTestWithHttpInfo(id = id)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Stop all the running jobs in a test.
     * 
     * @param id id
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun stopTestWithHttpInfo(id: kotlin.Long) : ApiResponse<Unit?> {
        val localVariableConfig = stopTestRequestConfig(id = id)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation stopTest
     *
     * @param id id
     * @return RequestConfig
     */
    fun stopTestRequestConfig(id: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        
        return RequestConfig(
            method = RequestMethod.GET,
            path = "/api/v1/tests/{id}/stop".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update test status - can only be called by worker instance.
     * 
     * @param testId testId
     * @param runId runId
     * @param taskId taskId
     * @param status status
     * @return kotlin.Boolean
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateStatus(testId: kotlin.Long, runId: kotlin.Long, taskId: kotlin.Long, status: StatusRequest) : kotlin.Boolean {
        val localVarResponse = updateStatusWithHttpInfo(testId = testId, runId = runId, taskId = taskId, status = status)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Boolean
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update test status - can only be called by worker instance.
     * 
     * @param testId testId
     * @param runId runId
     * @param taskId taskId
     * @param status status
     * @return ApiResponse<kotlin.Boolean?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateStatusWithHttpInfo(testId: kotlin.Long, runId: kotlin.Long, taskId: kotlin.Long, status: StatusRequest) : ApiResponse<kotlin.Boolean?> {
        val localVariableConfig = updateStatusRequestConfig(testId = testId, runId = runId, taskId = taskId, status = status)

        return request<StatusRequest, kotlin.Boolean>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateStatus
     *
     * @param testId testId
     * @param runId runId
     * @param taskId taskId
     * @param status status
     * @return RequestConfig
     */
    fun updateStatusRequestConfig(testId: kotlin.Long, runId: kotlin.Long, taskId: kotlin.Long, status: StatusRequest) : RequestConfig<StatusRequest> {
        val localVariableBody = status
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("runId", listOf(runId.toString()))
                put("taskId", listOf(taskId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/tests/{testId}/status".replace("{"+"testId"+"}", encodeURIComponent(testId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update test.
     * 
     * @param id The test ID.
     * @param testRequest testRequest
     * @return TestResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateTest(id: kotlin.Long, testRequest: TestRequest) : TestResponse {
        val localVarResponse = updateTestWithHttpInfo(id = id, testRequest = testRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update test.
     * 
     * @param id The test ID.
     * @param testRequest testRequest
     * @return ApiResponse<TestResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateTestWithHttpInfo(id: kotlin.Long, testRequest: TestRequest) : ApiResponse<TestResponse?> {
        val localVariableConfig = updateTestRequestConfig(id = id, testRequest = testRequest)

        return request<TestRequest, TestResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateTest
     *
     * @param id The test ID.
     * @param testRequest testRequest
     * @return RequestConfig
     */
    fun updateTestRequestConfig(id: kotlin.Long, testRequest: TestRequest) : RequestConfig<TestRequest> {
        val localVariableBody = testRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/tests/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }

    /**
     * Update test run.
     * 
     * @param id The test run ID.
     * @param request request
     * @return TestRunResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun updateTestRun(id: kotlin.Long, request: TestRunRequest) : TestRunResponse {
        val localVarResponse = updateTestRunWithHttpInfo(id = id, request = request)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TestRunResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Update test run.
     * 
     * @param id The test run ID.
     * @param request request
     * @return ApiResponse<TestRunResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun updateTestRunWithHttpInfo(id: kotlin.Long, request: TestRunRequest) : ApiResponse<TestRunResponse?> {
        val localVariableConfig = updateTestRunRequestConfig(id = id, request = request)

        return request<TestRunRequest, TestRunResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation updateTestRun
     *
     * @param id The test run ID.
     * @param request request
     * @return RequestConfig
     */
    fun updateTestRunRequestConfig(id: kotlin.Long, request: TestRunRequest) : RequestConfig<TestRunRequest> {
        val localVariableBody = request
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.PUT,
            path = "/api/v1/tests/testrun/{id}".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
